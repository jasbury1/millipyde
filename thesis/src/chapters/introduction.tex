\chapter{Introduction}

GPUs have incredible advantages when it comes to accelerating applications that expose data parallelism. In these applications, compute time often becomes a bottleneck when similar or identical operations are performed across large input data sets. The advantages provided by the SIMD (single-instruction, multiple-data) nature of GPUs allows programmers to create solutions for these problems that can run upwards of hundreds of times faster than solutions that run entirely on the CPU. This has given rise to the general-purpose GPU computing (GPGPU) paradigm where the use of GPUs has expanded far beyond their original purpose of accelerating graphical programs, and are now being targeted towards applications that traditionally would run on a CPU. Such GPGPU applications include image processing, video processing, audio signal processing, machine learning, and more.

\quad One disadvantage of GPGPU programming is that accelerating code on GPU devices often has a high barrier to entry. Often times the most performant tools and languages that allow for GPU acceleration map very closely to GPU hardware. This involves dividing the data into groups and hierarchies that can run efficiently on the given platform, and exploiting various memory systems on the device to find an optimal configuration. On top of this, many tools are platform-dependent. Tools, libraries, and frameworks that are built for the CUDA environment, for example, can only run on NVIDIA GPUs unless work is done to port them over to other devices.

\quad Many developers have recently aimed to solve this the tool-complexity problem by writing libraries and tools in the language Python. Python is a dynamically-typed multi-paradigm programming language with incredible abstraction capabilities. The speed and ease at which python code can be written in combination with a massive ecosystem of tools and libraries has made it a popular choice in scientific and engineering communities. By leveraging Python's natural abstraction level, many library designers aim to create Python tools that can more easily accelerate code for GPU devices without the typical knowledge overhead that was previously required for GPGPU programming. Such examples include TensorFlow for GPU-accelerated machine learning, Numba for just-in-time (JIT) NumPy compilation for GPUs, CuPy for GPU-accelerated computing, and more.

\quad This thesis introduces Millipyde which aims to be a framework that can be used in combination with NumPy and other NumPy compatible libraries to accelerate Python code on the GPU. Millipyde is one of few libraries that was created from the ground-up to run in AMD's ROCm ecosystem. Because of this, it is cross-platform capable and able to run seamlessly on a variety of both AMD and NVIDIA devices that support ROCm and its cross-platform C++ dialect HIP. Millipyde also focuses on multi-GPU capabilities and includes programming constructs for more easily accelerating functions across all devices recognized by the system. Millipyde is a young framework, and many plans exist for expanding upon the current functionality discussed in this thesis.

\quad The rest of this thesis will be outlined as follows. Chapter 2 will cover a variety of topics relevant to better understanding this thesis such as GPU computing, the ROCm ecosystem, and the Python language. Chapter 3 cover related Python libraries and framework for code acceleration and scientific computing. Chapter 4 explains how Millipyde was implemented with both its back-end and its Python interface. Chapter 5 shows an example of a Python image augmentation application written using the Millipyde framework. Chapter 6 evaluates Millipyde's performance using a variety of testing configurations. Chapter 7 discusses Millipyde at a high level including its acceleration benefits and the drawbacks of its current design. Chapter 8 lists many possible enhancements to the current design that Millipyde can incorporate in the future. Chapter 9 details the Millipyde API with code examples for how Millipyde can be used today within Python code. 